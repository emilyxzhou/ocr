import cv2
import glob
import numpy as np
import os
import random

from os.path import abspath, dirname

cwd = os.getcwd()


class Constants:
    # Folders
    DATA_FOLDER = os.path.join(dirname(dirname(dirname(abspath(__file__)))), "data")
    TRAIN_FOLDER = os.path.join(DATA_FOLDER, "training")
    VALIDATION_FOLDER = os.path.join(DATA_FOLDER, "validation")
    METADATA_FOLDER = os.path.join(DATA_FOLDER, "metadata")
    CHECKPOINTS_FOLDER = os.path.join(DATA_FOLDER, "checkpoints")
    OCR_TEST_FOLDER = os.path.join(DATA_FOLDER, "ocr_test")

    # Hex training data files
    ALL_FILES = glob.glob(f"{TRAIN_FOLDER}/*.jpg")
    HEX_FILES = glob.glob(f"{TRAIN_FOLDER}/[a-f]*.jpg") +glob.glob(f"{TRAIN_FOLDER}/[0-9]*.jpg")

    # ML info
    BATCH_SIZE = 32
    EPOCHS = 500
    HIDDEN_LAYER_SIZES = (150, 100, 50)
    CLASSES = "0123456789ABCDEFabcdefGHIJKLMNOPQRSTUVWXYZghijklmnopqrstuvwxyz"
    IMAGE_SIZE = 28

    # File paths
    CNN_WEIGHTS_PATH_FULL_H5 = os.path.join(DATA_FOLDER, "weights", "recognizer_pixel_operator_cnn_full.h5")
    CNN_WEIGHTS_PATH_HEX_H5 = os.path.join(DATA_FOLDER, "weights", "recognizer_pixel_operator_cnn_hex.h5")
    MLP_WEIGHTS_PATH_FULL = os.path.join(DATA_FOLDER, "weights", "recognizer_pixel_operator_mlp_full.pkl")
    MLP_WEIGHTS_PATH_HEX = os.path.join(DATA_FOLDER, "weights", "recognizer_pixel_operator_mlp_hex.pkl")
    CNN_WEIGHTS_PATH_FULL_CSV = os.path.join(DATA_FOLDER, "weights", "recognizer_pixel_operator_cnn_full.csv")
    CNN_WEIGHTS_PATH_HEX_CSV = os.path.join(DATA_FOLDER, "weights", "recognizer_pixel_operator_cnn_hex.csv")
    OCR_OUTPUT_FILE_FULL = os.path.join(DATA_FOLDER, "ocr_results_full.txt")
    OCR_OUTPUT_FILE_MLP = os.path.join(DATA_FOLDER, "ocr_results_mlp.txt")

    WEIGHTS_DICT = {
        "cnn": {
            "hex": CNN_WEIGHTS_PATH_HEX_H5,
            "full": CNN_WEIGHTS_PATH_FULL_H5
        },
        "mlp": {
            "hex": MLP_WEIGHTS_PATH_HEX,
            "full": MLP_WEIGHTS_PATH_FULL
        }
    }


def load_training_data(num_files=None, grayscale=True):
    """
    Loads full training dataset of characters A-Z and digits 0-9.
    :param num_files: Number of images to randomly load.
    :param grayscale: True to load images in grayscale (28x28x1), False otherwise (28x28x3).
    :return: A numpy array of images and a numpy array of corresponding labels.
    """
    image_paths = [
        f for f in os.listdir(Constants.TRAIN_FOLDER)
    ]

    if num_files is None:
        print("Loading all image files ...")
        num_files = len(image_paths)

    indices = random.sample(range(0, len(image_paths)), num_files)
    indices.sort()
    image_paths = [image_paths[i] for i in indices]
    labels = _read_labels(image_paths)
    full_image_paths = [
        os.path.join(Constants.TRAIN_FOLDER, f) for f in image_paths
    ]
    if grayscale:
        images = [cv2.imread(path, cv2.IMREAD_UNCHANGED) for path in full_image_paths]
    else:
        images = [cv2.imread(path) for path in full_image_paths]
    final_images = np.array([np.reshape(image, (Constants.IMAGE_SIZE, Constants.IMAGE_SIZE, 1)) for image in images])
    return final_images, labels


def load_hex_training_data(grayscale=True):
    """
    Loads hex dataset of characters A-F and digits 0-9.
    :param grayscale: True to load images in grayscale (28x28x1), False otherwise (28x28x3).
    :return: A numpy array of images and a numpy array of corresponding labels.
    """
    hex = list("0123456879ABCDEFabcdef")
    image_paths = [
        f for f in os.listdir(Constants.TRAIN_FOLDER) if f.split("_")[0] in hex
    ]
    labels = _read_labels(image_paths)

    full_image_paths = [
        os.path.join(Constants.TRAIN_FOLDER, f) for f in image_paths
    ]
    if grayscale:
        images = [cv2.imread(path, cv2.IMREAD_UNCHANGED) for path in full_image_paths]
    else:
        images = [cv2.imread(path) for path in full_image_paths]
    final_images = np.array([np.reshape(image, (Constants.IMAGE_SIZE, Constants.IMAGE_SIZE, 1)) for image in images])
    return final_images, labels


def _read_labels(image_paths):
    """
    :param image_paths: Paths to training images. Must be in the format {char_upper/lower}_{i}.jpg.
        Training images are generated by data_generator.py.
    :return: Numpy array of labels corresponding to input image paths.
    """
    print("Reading labels ...")
    count = 0
    labels = []

    for f in image_paths:
        file_info = f.split("_")
        char = file_info[0]
        if file_info[1] == "upper":
            char = char.upper()
        elif file_info[1] == "lower":
            char = char.lower()
        labels.append(_get_class_labels(char))
        # print(f"Image {count}/{total}")
        count += 1

    return np.array(labels)


def _get_class_labels(char):
    """
    :param char: Character to find the index of.
    :return: Index of input character according to Constants.CLASSES.
    """
    try:
        return Constants.CLASSES.index(char)
    except Exception:
        print("Invalid character")


def _get_box(image_path):
    image = cv2.imread(image_path)
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    white_rows = []
    white_cols = []
    for row in range(gray.shape[0]):
        for col in range(gray.shape[1]):
            if gray[row][col] > 10:
                white_rows.append(row)
                white_cols.append(col)

    min_row = min(white_rows) - 5
    min_col = min(white_cols) - 5
    max_row = max(white_rows) + 5
    max_col = max(white_cols) + 5

    return [
        [min_row, min_col],
        [min_row, max_col],
        [max_row, max_col],
        [max_row, min_col]
    ]


def scale_pixels(train):
    """
    :param train: Input image(s) as a single numpy array.
    :return: Input images with pixels normalized to the range [0, 1].
    """
    # Convert from integers to floats
    train_norm = train.astype("float32")
    # Normalize to range 0-1
    train_norm = train_norm / 255.0
    return train_norm


def get_class_labels_from_prediction(pred):
    """
    Used by the CNN model.
    :param pred: CNN model prediction.
    :return: Corresponding character according to Constants.CLASSES.
    """
    return Constants.CLASSES[np.argmax(pred)]


def get_label_from_file(file_path):
    """Returns the image label based on the file name."""
    file_info = file_path.split(os.sep)[-1]
    char = file_info[0]
    if not char.isdigit():
        char_type = file_info.split("_")[1]
        if char_type == "upper":
            char = char.upper()
    return char


def display_image(image, name="image"):
    cv2.namedWindow(name, cv2.WINDOW_NORMAL)
    width = 700
    # Scale image to window width
    height = int(width / image.shape[1] * image.shape[0])
    cv2.resizeWindow(name, width, height)
    cv2.imshow(name, image)
    cv2.waitKey(0)
    cv2.destroyWindow(name)
