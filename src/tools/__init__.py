import cv2
import numpy as np
import os
import random

from os.path import abspath, dirname

cwd = os.getcwd()


class Constants:
    # Folders
    DATA_FOLDER = os.path.join(dirname(dirname(dirname(abspath(__file__)))), "data")
    TRAIN_FOLDER = os.path.join(DATA_FOLDER, "training")
    VALIDATION_FOLDER = os.path.join(DATA_FOLDER, "validation")
    METADATA_FOLDER = os.path.join(DATA_FOLDER, "metadata")
    CHECKPOINTS_FOLDER = os.path.join(DATA_FOLDER, "checkpoints")
    OCR_TEST_FOLDER = os.path.join(DATA_FOLDER, "ocr_test")

    # ML info
    CLASSES = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    IMAGE_SIZE = 28

    # File paths
    CNN_WEIGHTS_PATH_FULL_H5 = os.path.join(DATA_FOLDER, "weights", "recognizer_pixel_operator_cnn_full.h5")
    CNN_WEIGHTS_PATH_HEX_H5 = os.path.join(DATA_FOLDER, "weights", "recognizer_pixel_operator_cnn_hex.h5")
    MLP_WEIGHTS_PATH_FULL = os.path.join(DATA_FOLDER, "weights", "recognizer_pixel_operator_mlp_full.pkl")
    MLP_WEIGHTS_PATH_HEX = os.path.join(DATA_FOLDER, "weights", "recognizer_pixel_operator_mlp_hex.pkl")
    CNN_WEIGHTS_PATH_FULL_CSV = os.path.join(DATA_FOLDER, "weights", "recognizer_pixel_operator_cnn_full.csv")
    CNN_WEIGHTS_PATH_HEX_CSV = os.path.join(DATA_FOLDER, "weights", "recognizer_pixel_operator_cnn_hex.csv")
    OCR_OUTPUT_FILE_FULL = os.path.join(DATA_FOLDER, "ocr_results_full.txt")
    OCR_OUTPUT_FILE_MLP = os.path.join(DATA_FOLDER, "ocr_results_mlp.txt")


def load_training_data(num_files=None, grayscale=True):
    """
    Loads full training dataset of characters A-Z and digits 0-9.
    :param num_files: Number of images to randomly load.
    :param grayscale: True to load images in grayscale (28x28x1), False otherwise (28x28x3).
    :return: A numpy array of images and a numpy array of corresponding labels.
    """
    image_paths = [
        f for f in os.listdir(Constants.TRAIN_FOLDER)
    ]

    if num_files is None:
        print("Loading all image files ...")
        num_files = len(image_paths)

    indices = random.sample(range(0, len(image_paths)), num_files)
    indices.sort()
    image_paths = [image_paths[i] for i in indices]
    labels = _read_labels(image_paths)
    full_image_paths = [
        os.path.join(Constants.TRAIN_FOLDER, f) for f in image_paths
    ]
    if grayscale:
        images = [cv2.imread(path, cv2.IMREAD_UNCHANGED) for path in full_image_paths]
    else:
        images = [cv2.imread(path) for path in full_image_paths]
    final_images = np.array([np.reshape(image, (28, 28, 1)) for image in images])
    return final_images, labels


def load_hex_training_data(grayscale=True):
    """
    Loads hex dataset of characters A-F and digits 0-9.
    :param grayscale: True to load images in grayscale (28x28x1), False otherwise (28x28x3).
    :return: A numpy array of images and a numpy array of corresponding labels.
    """
    hex = list("0123456879ABCDEF")
    image_paths = [
        f for f in os.listdir(Constants.TRAIN_FOLDER) if f.split("_")[0] in hex
    ]
    labels = _read_labels(image_paths)
    full_image_paths = [
        os.path.join(Constants.TRAIN_FOLDER, f) for f in image_paths
    ]
    if grayscale:
        images = [cv2.imread(path, cv2.IMREAD_UNCHANGED) for path in full_image_paths]
    else:
        images = [cv2.imread(path) for path in full_image_paths]
    final_images = np.array([np.reshape(image, (28, 28, 1)) for image in images])
    return final_images, labels


def _read_labels(image_paths):
    """
    :param image_paths: Paths to training images. Must be in the format {char}_{i}.jpg.
        Training images are generated by data_generator.py.
    :return: NUmpy array of labels corresponding to input image paths.
    """
    print("Reading labels ...")
    count = 0
    symbols = "\"\"\\!@#$%^&*()-_=+,./<>?;:|~`[]{}"
    symbols = [sym for sym in symbols]
    labels = []

    for f in image_paths:
        file_info = f.split("_")
        if len(file_info[0]) > 1:  # text is a symbol instead of a character
            symbol_index = int(file_info[1])
            labels.append(symbols[symbol_index])
        else:
            char = file_info[0].split(".")[0]
            labels.append(_get_class_labels(char))
        # print(f"Image {count}/{total}")
        count += 1

    return np.array(labels)


def _get_class_labels(char):
    """
    :param char: Character to find the index of.
    :return: Index of input character according to Constants.CLASSES.
    """
    try:
        return Constants.CLASSES.index(char)
    except Exception:
        print("Invalid character")


def _get_box(image_path):
    image = cv2.imread(image_path)
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    white_rows = []
    white_cols = []
    for row in range(gray.shape[0]):
        for col in range(gray.shape[1]):
            if gray[row][col] > 10:
                white_rows.append(row)
                white_cols.append(col)

    min_row = min(white_rows) - 5
    min_col = min(white_cols) - 5
    max_row = max(white_rows) + 5
    max_col = max(white_cols) + 5

    return [
        [min_row, min_col],
        [min_row, max_col],
        [max_row, max_col],
        [max_row, min_col]
    ]


def scale_pixels(train):
    """
    :param train: Input image(s) as a single numpy array.
    :return: Input images with pixels normalized to the range [0, 1].
    """
    # Convert from integers to floats
    train_norm = train.astype("float32")
    # Normalize to range 0-1
    train_norm = train_norm / 255.0
    return train_norm


def get_class_labels_from_prediction(pred):
    """
    Used by the CNN model.
    :param pred: CNN model prediction.
    :return: Corresponding character according to Constants.CLASSES.
    """
    return Constants.CLASSES[np.argmax(pred)]
